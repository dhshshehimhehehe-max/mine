-- TeleportOreUI.lua
-- LocalScript for a draggable, minimizable UI that lists ores in categories and teleports the player to a clicked ore type.
-- Behavior:
--  - Detects which world (PlaceId) you're in and applies the appropriate excluded-ore blacklist.
--  - Scans workspace.Mine for ore parts and groups available ore types into categories (Stone, Metal, Gem, Other).
--  - Builds a UI in PlayerGui that's draggable and minimizable. Each ore type is a button that shows current available count.
--  - Clicking an ore button teleports your character to the nearest ore of that type. If that ore is mined, clicking again will try to teleport to another available ore of the same type.
--  - The UI automatically refreshes when ores are added/removed in workspace.Mine.
-- Note: This script is written as a LocalScript and should run in a LocalPlayer context.

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local player = Players.LocalPlayer

if not player then
    -- If running too early, wait for player
    player = Players:GetPropertyChangedSignal("LocalPlayer") and Players.LocalPlayer or Players.PlayerAdded:Wait()
end

local playerGui = player:WaitForChild("PlayerGui")
local workspace = game:GetService("Workspace")

-- Determine excluded ores per PlaceId (the lists you provided are used as blacklist)
local excludedOres = {}
if game.PlaceId == 8549934015 then -- Normal World
    excludedOres = {"Magma", "Stone", "Copper", "Basalt", "Amber", "Diorite", "Coal", "Crystallized Stone", "Nickel", "Bedrock", "Gold", "Granite", "Iron", "Marble", "Etherstone", "Prismatistone","Silver","Obsidian","Ice","Voidstone","Ruby","Celestone","Mantle","Goldstone","Barrier","Quartz","Reflectistone","Emerald"}
elseif game.PlaceId == 10129505074 then -- Moon World
    excludedOres = {"Moon Stone", "Tin", "Moon Mantle", "Jasper", "Aluminum", "Moon Core", "Zinc", "Coal", "Magma", "Copper", "Titanium", "Legacy Uranium", "Lithium", "Nickel", "Quartz", "Gold", "Tourmaline","Jade","Silver","Lapis Lazuli","Bismuth","Nebula","Strontium","Scandium","Platinum","Amethyst","Barrier","Garnet","Cobalt","Emerald","Heliodor","Aquamarine","Topaz","Diamond","Beryllium","Morganite","Ruby","Rocc","Moonrock","nil"}
else
    -- Default: empty blacklist
    excludedOres = {}
end

local function isExcluded(name)
    for _, v in pairs(excludedOres) do
        if v == name then
            return true
        end
    end
    return false
end

-- Folder with ore parts
local mineFolder = workspace:FindFirstChild("Mine") or workspace:WaitForChild("Mine")

-- Utility: categorize ore by name using simple keyword heuristics
local categoryKeywords = {
    Stone = {"stone", "rock", "bedrock", "mantle", "moon rock", "moonrock"},
    Metal = {"iron", "copper", "gold", "nickel", "tin", "aluminum", "platinum", "titanium", "zinc", "bismuth", "beryllium", "scandium", "strontium", "cobalt"},
    Gem = {"ruby", "emerald", "diamond", "amethyst", "jade", "topaz", "aquamarine", "garnet", "morganite", "tourmaline", "opal", "heliodor", "lapis", "opal"},
}

local function categorizeOre(name)
    local lower = string.lower(name or "")
    for cat, keywords in pairs(categoryKeywords) do
        for _, kw in ipairs(keywords) do
            if string.find(lower, kw, 1, true) then
                return cat
            end
        end
    end
    return "Other"
end

-- GUI creation
local gui = Instance.new("ScreenGui")
gui.Name = "OreTeleportUI"
gui.ResetOnSpawn = false
gui.Parent = playerGui

-- Main frame / title bar
local mainFrame = Instance.new("Frame")
mainFrame.Name = "Main"
mainFrame.Size = UDim2.new(0, 360, 0, 420)
mainFrame.Position = UDim2.new(0, 50, 0, 80)
mainFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
mainFrame.BorderSizePixel = 0
mainFrame.Parent = gui
mainFrame.Active = true

local titleBar = Instance.new("Frame")
titleBar.Name = "TitleBar"
titleBar.Size = UDim2.new(1, 0, 0, 34)
titleBar.BackgroundColor3 = Color3.fromRGB(20, 20, 25)
titleBar.BorderSizePixel = 0
titleBar.Parent = mainFrame

local titleLabel = Instance.new("TextLabel")
titleLabel.Name = "Title"
titleLabel.Size = UDim2.new(1, -70, 1, 0)
titleLabel.Position = UDim2.new(0, 10, 0, 0)
titleLabel.BackgroundTransparency = 1
titleLabel.Text = "Ore Teleport"
titleLabel.TextColor3 = Color3.fromRGB(220,220,220)
titleLabel.TextScaled = true
titleLabel.Font = Enum.Font.GothamBold
titleLabel.TextXAlignment = Enum.TextXAlignment.Left
titleLabel.Parent = titleBar

local minimizeBtn = Instance.new("TextButton")
minimizeBtn.Name = "Minimize"
minimizeBtn.Size = UDim2.new(0, 30, 0, 24)
minimizeBtn.Position = UDim2.new(1, -36, 0, 5)
minimizeBtn.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
minimizeBtn.Text = "-"
minimizeBtn.Font = Enum.Font.GothamBold
minimizeBtn.TextColor3 = Color3.fromRGB(200,200,200)
minimizeBtn.TextScaled = true
minimizeBtn.Parent = titleBar

local contentFrame = Instance.new("Frame")
contentFrame.Name = "Content"
contentFrame.Size = UDim2.new(1, 0, 1, -34)
contentFrame.Position = UDim2.new(0, 0, 0, 34)
contentFrame.BackgroundTransparency = 1
contentFrame.Parent = mainFrame

local scroll = Instance.new("ScrollingFrame")
scroll.Name = "Scroll"
scroll.Size = UDim2.new(1, -12, 1, -12)
scroll.Position = UDim2.new(0, 6, 0, 6)
scroll.CanvasSize = UDim2.new(0, 0, 0, 0)
scroll.BackgroundTransparency = 1
scroll.ScrollBarThickness = 6
scroll.Parent = contentFrame

local layout = Instance.new("UIListLayout")
layout.SortOrder = Enum.SortOrder.LayoutOrder
layout.Padding = UDim.new(0, 6)
layout.Parent = scroll

-- For storing buttons by ore name
local oreButtons = {}

-- More efficient part bookkeeping:
-- partsByName[name] = { parts = { [part] = true }, count = n }
local partsByName = {}
local partConnections = {} -- track per-part AncestryChanged connections so we can disconnect

-- Highlight / optional box adornment on target ore
local currentHighlight = nil
local function clearHighlight()
    if currentHighlight and currentHighlight.Parent then
        currentHighlight:Destroy()
    end
    currentHighlight = nil
end

local function createHighlight(part)
    clearHighlight()
    if not part or not part:IsA("BasePart") then return end
    local box = Instance.new("BoxHandleAdornment")
    box.Adornee = part
    box.AlwaysOnTop = true
    box.Size = part.Size + Vector3.new(0.08, 0.08, 0.08)
    box.ZIndex = 10
    box.Color = part.Color
    box.Parent = game:GetService("CoreGui")
    currentHighlight = box
end

-- Teleport function (unchanged)
local function teleportToOre(oreName)
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
        player.CharacterAdded:Wait()
        repeat wait() until player.Character:FindFirstChild("HumanoidRootPart")
    end
    local hrp = player.Character.HumanoidRootPart
    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
    if not hrp then return end

    local nearest = nil
    local nearestDist = math.huge
    local entry = partsByName[oreName]
    if entry then
        for part,_ in pairs(entry.parts) do
            if part and part:IsA("BasePart") then
                local dist = (hrp.Position - part.Position).Magnitude
                if dist < nearestDist then
                    nearest = part
                    nearestDist = dist
                end
            end
        end
    end

    if nearest then
        local targetCFrame = nearest.CFrame + Vector3.new(0, 6.5, 0)
        if humanoid and humanoid.Sit then
            humanoid.Sit = false
        end
        hrp.CFrame = targetCFrame
        createHighlight(nearest)
    else
        clearHighlight()
    end
end

-- GUI helper: create a button for an ore type (called only when an ore type first appears)
local function createButtonForOre(oreName)
    local cat = categorizeOre(oreName)
    -- Try to find an existing category grid for this category; if not found, rebuild full UI
    local grid = scroll:FindFirstChild("Grid_" .. cat)
    if not grid then
        -- Category not present yet â€” rebuild the full UI (rare)
        spawn(rebuildUI)
        return
    end

    local btn = Instance.new("TextButton")
    btn.Name = "OreBtn_" .. oreName
    btn.Size = UDim2.new(0, 110, 0, 36)
    btn.BackgroundColor3 = Color3.fromRGB(42, 42, 48)
    btn.BorderSizePixel = 0
    btn.Text = oreName
    btn.Font = Enum.Font.Gotham
    btn.TextSize = 14
    btn.TextColor3 = Color3.fromRGB(230,230,230)
    btn.AutoButtonColor = true
    btn.LayoutOrder = 1
    btn.Parent = grid

    local countLabel = Instance.new("TextLabel")
    countLabel.Name = "Count"
    countLabel.Size = UDim2.new(0, 34, 1, 0)
    countLabel.Position = UDim2.new(1, -36, 0, 0)
    countLabel.BackgroundTransparency = 1
    countLabel.Text = "0"
    countLabel.Font = Enum.Font.Gotham
    countLabel.TextSize = 14
    countLabel.TextColor3 = Color3.fromRGB(170,170,170)
    countLabel.Parent = btn

    btn.MouseButton1Click:Connect(function()
        teleportToOre(oreName)
    end)

    oreButtons[oreName] = {
        Button = btn,
        Count = countLabel,
    }
end

-- Rebuild the whole UI (runs rarely: initial load or when categories change)
function rebuildUI()
    -- Clear previous category frames (but keep template if any)
    for _, child in ipairs(scroll:GetChildren()) do
        if child:IsA("Frame") and child.Name:match("^Category_") then
            child:Destroy()
        elseif child:IsA("Frame") and child.Name:match("^Grid_") then
            child:Destroy()
        end
    end

    oreButtons = {}

    -- Compute oreTypes from partsByName
    local oreTypes = {}
    for name, entry in pairs(partsByName) do
        if entry.count and entry.count > 0 then
            oreTypes[name] = true
        end
    end

    local categories = {}
    for oreName, _ in pairs(oreTypes) do
        local cat = categorizeOre(oreName)
        categories[cat] = categories[cat] or {}
        table.insert(categories[cat], oreName)
    end

    local catNames = {}
    for k in pairs(categories) do table.insert(catNames, k) end
    table.sort(catNames)

    local yOffset = 0
    for _, catName in ipairs(catNames) do
        local catFrame = Instance.new("Frame")
        catFrame.Name = "Category_" .. catName
        catFrame.Size = UDim2.new(1, -6, 0, 28)
        catFrame.LayoutOrder = yOffset
        catFrame.BackgroundTransparency = 1
        catFrame.Parent = scroll

        local catLabel = Instance.new("TextLabel")
        catLabel.Size = UDim2.new(1, 0, 1, 0)
        catLabel.BackgroundTransparency = 1
        catLabel.Text = catName
        catLabel.TextColor3 = Color3.fromRGB(200,200,200)
        catLabel.Font = Enum.Font.GothamBold
        catLabel.TextScaled = true
        catLabel.Parent = catFrame

        local grid = Instance.new("Frame")
        grid.Name = "Grid_" .. catName
        grid.Size = UDim2.new(1, 0, 0, 0) -- will grow
        grid.BackgroundTransparency = 1
        grid.Parent = scroll

        local gridLayout = Instance.new("UIGridLayout")
        gridLayout.CellSize = UDim2.new(0, 110, 0, 36)
        gridLayout.CellPadding = UDim2.new(0, 6, 0, 6)
        gridLayout.FillDirection = Enum.FillDirection.Horizontal
        gridLayout.SortOrder = Enum.SortOrder.LayoutOrder
        gridLayout.Parent = grid

        table.sort(categories[catName])
        for _, oreName in ipairs(categories[catName]) do
            createButtonForOre(oreName)
        end

        yOffset = yOffset + 1
    end

    -- Adjust canvas size after layout finishes
    task.defer(function()
        wait() -- allow layouts to compute
        local contentSize = layout.AbsoluteContentSize
        scroll.CanvasSize = UDim2.new(0, 0, 0, contentSize.Y + 8)
    end)
end

-- Efficient part add/remove functions:
local function updateButtonCount(oreName)
    local entry = partsByName[oreName]
    local count = (entry and entry.count) or 0
    local btnObj = oreButtons[oreName]
    if btnObj and btnObj.Count then
        local prev = tonumber(btnObj.Count.Text) or 0
        if prev ~= count then
            btnObj.Count.Text = tostring(count)
            btnObj.Button.Active = count > 0
            btnObj.Button.BackgroundColor3 = count > 0 and Color3.fromRGB(42,42,48) or Color3.fromRGB(28,28,30)
            btnObj.Button.TextTransparency = count > 0 and 0 or 0.4
        end
    else
        -- If button doesn't exist but we have parts for this ore => create button (lazy)
        if count > 0 then
            createButtonForOre(oreName)
            updateButtonCount(oreName)
        end
    end
end

local function removePart(part)
    if not part or not part.Name then return end
    local name = part.Name
    local entry = partsByName[name]
    if entry and entry.parts[part] then
        entry.parts[part] = nil
        entry.count = entry.count - 1
        if entry.count <= 0 then
            partsByName[name] = nil
            -- keep the button but disable it (faster than destroying the UI)
        end
        updateButtonCount(name)
    end
    if partConnections[part] then
        partConnections[part]:Disconnect()
        partConnections[part] = nil
    end
end

local function addPart(part)
    if not part or not part:IsA("BasePart") then return end
    local name = part.Name
    if isExcluded(name) then return end
    partsByName[name] = partsByName[name] or { parts = {}, count = 0 }
    if not partsByName[name].parts[part] then
        partsByName[name].parts[part] = true
        partsByName[name].count = partsByName[name].count + 1
    end

    -- connect to AncestryChanged to detect removal or parent nil -> cleanup
    local conn = part.AncestryChanged:Connect(function(_, parent)
        if not parent then
            removePart(part)
        end
    end)
    partConnections[part] = conn

    updateButtonCount(name)
end

-- Initial single pass scan (only once) to populate partsByName
do
    local children = mineFolder:GetChildren()
    for _, child in ipairs(children) do
        if child:IsA("BasePart") and not isExcluded(child.Name) then
            addPart(child)
        end
    end
end

-- Rebuild UI once after initial scan
rebuildUI()

-- Connect to ChildAdded/ChildRemoved but keep work minimal: only add/remove single part,
-- don't full-scan. Rebuild UI only if category is new (handled lazily in createButtonForOre).
mineFolder.ChildAdded:Connect(function(child)
    -- quick add
    addPart(child)
end)

mineFolder.ChildRemoved:Connect(function(child)
    -- child may already have been handled by AncestryChanged, but handle just in case
    removePart(child)
end)

-- Throttled refresh: we don't scan all ores every frame; we only update UI labels when values change.
-- Use a simple timer to call updateButtonCount for all known oreButtons at most every 0.5s
local lastRefresh = 0
local REFRESH_INTERVAL = 0.5

RunService.Heartbeat:Connect(function(dt)
    lastRefresh = lastRefresh + dt
    if lastRefresh >= REFRESH_INTERVAL then
        lastRefresh = 0
        -- update visible buttons counts (cheap: iterate oreButtons keys, not all parts)
        for oreName, _ in pairs(oreButtons) do
            updateButtonCount(oreName)
        end
    end
end)

-- Dragging logic for titleBar (unchanged)
local dragging = false
local dragInput, dragStart, startPos

local function updatePosition(input)
    local delta = input.Position - dragStart
    mainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
end

titleBar.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = mainFrame.Position
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

titleBar.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        dragInput = input
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if dragging and input == dragInput then
        updatePosition(input)
    end
end)

-- Minimize toggle
local minimized = false
local originalSize = mainFrame.Size
minimizeBtn.MouseButton1Click:Connect(function()
    minimized = not minimized
    if minimized then
        TweenService:Create(mainFrame, TweenInfo.new(0.18), {Size = UDim2.new(originalSize.X.Scale, originalSize.X.Offset, 0, 34)}):Play()
        contentFrame.Visible = false
    else
        contentFrame.Visible = true
        TweenService:Create(mainFrame, TweenInfo.new(0.18), {Size = originalSize}):Play()
    end
end)

-- Keybind to teleport to random available ore (kept but uses partsByName now)
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.Nine then
        local availableTypes = {}
        for oreName, entry in pairs(partsByName) do
            if entry.count and entry.count > 0 then
                table.insert(availableTypes, oreName)
            end
        end
        if #availableTypes > 0 then
            local choice = availableTypes[math.random(1, #availableTypes)]
            teleportToOre(choice)
        end
    end
end)

-- Keep UI alive on respawn: re-parent if PlayerGui resets
player.CharacterAdded:Connect(function()
    wait(0.2)
    if not gui.Parent then
        gui.Parent = playerGui
    end
end)

-- Clean up on script destroy
script.Destroying:Connect(function()
    clearHighlight()
    for c,_ in pairs(partConnections) do
        if c and c.Disconnect then
            c:Disconnect()
        end
    end
end)
