-- TeleportOreUI.lua
-- LocalScript â€” same functionality as before but optimized to avoid freezing when the UI loads.
-- Changes:
--  - Uses a master ore list per world so the UI can show "all ores" (including count 0) without building UI from live parts.
--  - Creates buttons in small batches (chunked creation) so the game doesn't freeze while the UI is built.
--  - Performs initial part-count scan in batches to avoid a single big-frame scan.
--  - Keeps incremental bookkeeping (partsByName) so we don't rescan the whole folder every frame.
--  - Adds an option to toggle counts (turn off live counts to reduce updates further).
-- Place this as a LocalScript under StarterGui or otherwise run in a LocalPlayer context.

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local task = task
local player = Players.LocalPlayer

if not player then
    player = Players:GetPropertyChangedSignal("LocalPlayer") and Players.LocalPlayer or Players.PlayerAdded:Wait()
end

local playerGui = player:WaitForChild("PlayerGui")
local workspace = game:GetService("Workspace")

-- === Master ore lists per PlaceId ===
-- Populate with the ore names you want shown in the UI (all ores, even if they don't exist yet).
local masterOreList = {}
if game.PlaceId == 8549934015 then -- Normal World
    masterOreList = {
        "Magma","Stone","Copper","Basalt","Amber","Diorite","Coal","Crystallized Stone","Nickel","Bedrock","Gold","Granite","Iron",
        "Marble","Etherstone","Prismatistone","Silver","Obsidian","Ice","Voidstone","Ruby","Celestone","Mantle","Goldstone","Barrier",
        "Quartz","Reflectistone","Emerald",
        -- add any other ore names you want shown
    }
elseif game.PlaceId == 10129505074 then -- Moon World
    masterOreList = {
        "Moon Stone","Tin","Moon Mantle","Jasper","Aluminum","Moon Core","Zinc","Coal","Magma","Copper","Titanium","Legacy Uranium",
        "Lithium","Nickel","Quartz","Gold","Tourmaline","Jade","Silver","Lapis Lazuli","Bismuth","Nebula","Strontium","Scandium",
        "Platinum","Amethyst","Barrier","Garnet","Cobalt","Emerald","Heliodor","Aquamarine","Topaz","Diamond","Beryllium","Morganite",
        "Ruby","Rocc","Moonrock",
        -- add any other ore names you want shown
    }
else
    -- fallback: small example list to avoid building an enormous UI by accident
    masterOreList = {"Stone", "Iron", "Gold", "Diamond"}
end

-- Blacklist (keeps the prior behavior if you still want to exclude some names from scanning/bookkeeping)
local excludedOres = {}
if game.PlaceId == 8549934015 then
    excludedOres = {"Magma", "Stone"} -- trim if needed; but we keep master list for UI display
elseif game.PlaceId == 10129505074 then
    excludedOres = {} -- example
end

local function isExcluded(name)
    for _, v in pairs(excludedOres) do
        if v == name then
            return true
        end
    end
    return false
end

-- Folder with ore parts
local mineFolder = workspace:FindFirstChild("Mine") or workspace:WaitForChild("Mine")

-- Utility: categorize ore by name using simple keyword heuristics
local categoryKeywords = {
    Stone = {"stone", "rock", "bedrock", "mantle", "moon rock", "moonrock"},
    Metal = {"iron", "copper", "gold", "nickel", "tin", "aluminum", "platinum", "titanium", "zinc", "bismuth", "beryllium", "scandium", "strontium", "cobalt"},
    Gem = {"ruby", "emerald", "diamond", "amethyst", "jade", "topaz", "aquamarine", "garnet", "morganite", "tourmaline", "opal", "heliodor", "lapis"},
}

local function categorizeOre(name)
    local lower = string.lower(name or "")
    for cat, keywords in pairs(categoryKeywords) do
        for _, kw in ipairs(keywords) do
            if string.find(lower, kw, 1, true) then
                return cat
            end
        end
    end
    return "Other"
end

-- === GUI creation (same look) ===
local gui = Instance.new("ScreenGui")
gui.Name = "OreTeleportUI"
gui.ResetOnSpawn = false
gui.Parent = playerGui

local mainFrame = Instance.new("Frame")
mainFrame.Name = "Main"
mainFrame.Size = UDim2.new(0, 360, 0, 420)
mainFrame.Position = UDim2.new(0, 50, 0, 80)
mainFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
mainFrame.BorderSizePixel = 0
mainFrame.Parent = gui
mainFrame.Active = true

local titleBar = Instance.new("Frame")
titleBar.Name = "TitleBar"
titleBar.Size = UDim2.new(1, 0, 0, 34)
titleBar.BackgroundColor3 = Color3.fromRGB(20, 20, 25)
titleBar.BorderSizePixel = 0
titleBar.Parent = mainFrame

local titleLabel = Instance.new("TextLabel")
titleLabel.Name = "Title"
titleLabel.Size = UDim2.new(1, -100, 1, 0)
titleLabel.Position = UDim2.new(0, 10, 0, 0)
titleLabel.BackgroundTransparency = 1
titleLabel.Text = "Ore Teleport"
titleLabel.TextColor3 = Color3.fromRGB(220,220,220)
titleLabel.TextScaled = true
titleLabel.Font = Enum.Font.GothamBold
titleLabel.TextXAlignment = Enum.TextXAlignment.Left
titleLabel.Parent = titleBar

local minimizeBtn = Instance.new("TextButton")
minimizeBtn.Name = "Minimize"
minimizeBtn.Size = UDim2.new(0, 30, 0, 24)
minimizeBtn.Position = UDim2.new(1, -36, 0, 5)
minimizeBtn.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
minimizeBtn.Text = "-"
minimizeBtn.Font = Enum.Font.GothamBold
minimizeBtn.TextColor3 = Color3.fromRGB(200,200,200)
minimizeBtn.TextScaled = true
minimizeBtn.Parent = titleBar

-- Toggle to enable/disable counts (reduces UI updates if you turn counts off)
local showCounts = true
local toggleCountsBtn = Instance.new("TextButton")
toggleCountsBtn.Name = "ToggleCounts"
toggleCountsBtn.Size = UDim2.new(0, 80, 0, 22)
toggleCountsBtn.Position = UDim2.new(1, -130, 0, 6)
toggleCountsBtn.BackgroundColor3 = Color3.fromRGB(50,50,55)
toggleCountsBtn.Text = "Counts: On"
toggleCountsBtn.Font = Enum.Font.Gotham
toggleCountsBtn.TextSize = 14
toggleCountsBtn.TextColor3 = Color3.fromRGB(220,220,220)
toggleCountsBtn.Parent = titleBar

local contentFrame = Instance.new("Frame")
contentFrame.Name = "Content"
contentFrame.Size = UDim2.new(1, 0, 1, -34)
contentFrame.Position = UDim2.new(0, 0, 0, 34)
contentFrame.BackgroundTransparency = 1
contentFrame.Parent = mainFrame

local scroll = Instance.new("ScrollingFrame")
scroll.Name = "Scroll"
scroll.Size = UDim2.new(1, -12, 1, -12)
scroll.Position = UDim2.new(0, 6, 0, 6)
scroll.CanvasSize = UDim2.new(0, 0, 0, 0)
scroll.BackgroundTransparency = 1
scroll.ScrollBarThickness = 6
scroll.Parent = contentFrame

local layout = Instance.new("UIListLayout")
layout.SortOrder = Enum.SortOrder.LayoutOrder
layout.Padding = UDim.new(0, 6)
layout.Parent = scroll

-- For storing UI objects and part bookkeeping
local oreButtons = {} -- oreName -> { Button, CountLabel }
local partsByName = {} -- oreName -> { parts = { [part] = true }, count = n }
local partConnections = {} -- part -> connection

-- Highlight (unchanged)
local currentHighlight = nil
local function clearHighlight()
    if currentHighlight and currentHighlight.Parent then
        currentHighlight:Destroy()
    end
    currentHighlight = nil
end
local function createHighlight(part)
    clearHighlight()
    if not part or not part:IsA("BasePart") then return end
    local box = Instance.new("BoxHandleAdornment")
    box.Adornee = part
    box.AlwaysOnTop = true
    box.Size = part.Size + Vector3.new(0.08, 0.08, 0.08)
    box.ZIndex = 10
    box.Color = part.Color
    box.Parent = game:GetService("CoreGui")
    currentHighlight = box
end

-- Teleport (uses partsByName so we don't scan the folder at click time)
local function teleportToOre(oreName)
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
        player.CharacterAdded:Wait()
        repeat task.wait() until player.Character:FindFirstChild("HumanoidRootPart")
    end
    local hrp = player.Character.HumanoidRootPart
    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
    if not hrp then return end

    local entry = partsByName[oreName]
    local nearest, nearestDist = nil, math.huge
    if entry then
        for part,_ in pairs(entry.parts) do
            if part and part:IsA("BasePart") then
                local dist = (hrp.Position - part.Position).Magnitude
                if dist < nearestDist then
                    nearest = part
                    nearestDist = dist
                end
            end
        end
    end

    if nearest then
        local targetCFrame = nearest.CFrame + Vector3.new(0, 6.5, 0)
        if humanoid and humanoid.Sit then
            humanoid.Sit = false
        end
        hrp.CFrame = targetCFrame
        createHighlight(nearest)
    else
        clearHighlight()
    end
end

-- Create category frames (if needed) and grid containers
local function ensureCategoryExists(catName)
    if scroll:FindFirstChild("Grid_" .. catName) then return end
    local catFrame = Instance.new("Frame")
    catFrame.Name = "Category_" .. catName
    catFrame.Size = UDim2.new(1, -6, 0, 28)
    catFrame.BackgroundTransparency = 1
    catFrame.Parent = scroll

    local catLabel = Instance.new("TextLabel")
    catLabel.Size = UDim2.new(1, 0, 1, 0)
    catLabel.BackgroundTransparency = 1
    catLabel.Text = catName
    catLabel.TextColor3 = Color3.fromRGB(200,200,200)
    catLabel.Font = Enum.Font.GothamBold
    catLabel.TextScaled = true
    catLabel.Parent = catFrame

    local grid = Instance.new("Frame")
    grid.Name = "Grid_" .. catName
    grid.Size = UDim2.new(1, 0, 0, 0)
    grid.BackgroundTransparency = 1
    grid.Parent = scroll

    local gridLayout = Instance.new("UIGridLayout")
    gridLayout.CellSize = UDim2.new(0, 110, 0, 36)
    gridLayout.CellPadding = UDim2.new(0, 6, 0, 6)
    gridLayout.FillDirection = Enum.FillDirection.Horizontal
    gridLayout.SortOrder = Enum.SortOrder.LayoutOrder
    gridLayout.Parent = grid
end

-- Create a single button for oreName
local function createButtonForOre(oreName)
    if oreButtons[oreName] then return end
    local cat = categorizeOre(oreName)
    ensureCategoryExists(cat)
    local grid = scroll:FindFirstChild("Grid_" .. cat)
    if not grid then return end

    local btn = Instance.new("TextButton")
    btn.Name = "OreBtn_" .. oreName
    btn.Size = UDim2.new(0, 110, 0, 36)
    btn.BackgroundColor3 = Color3.fromRGB(42, 42, 48)
    btn.BorderSizePixel = 0
    btn.Text = oreName
    btn.Font = Enum.Font.Gotham
    btn.TextSize = 14
    btn.TextColor3 = Color3.fromRGB(230,230,230)
    btn.AutoButtonColor = true
    btn.Parent = grid

    local countLabel = Instance.new("TextLabel")
    countLabel.Name = "Count"
    countLabel.Size = UDim2.new(0, 34, 1, 0)
    countLabel.Position = UDim2.new(1, -36, 0, 0)
    countLabel.BackgroundTransparency = 1
    countLabel.Text = "0"
    countLabel.Font = Enum.Font.Gotham
    countLabel.TextSize = 14
    countLabel.TextColor3 = Color3.fromRGB(170,170,170)
    countLabel.Parent = btn
    countLabel.Visible = showCounts

    btn.MouseButton1Click:Connect(function()
        teleportToOre(oreName)
    end)

    oreButtons[oreName] = {
        Button = btn,
        Count = countLabel,
    }
end

-- Build all buttons from master list in batches to avoid freezing
local function buildButtonsInBatches(list, batchSize)
    batchSize = batchSize or 25
    local i = 1
    while i <= #list do
        local last = math.min(#list, i + batchSize - 1)
        for j = i, last do
            createButtonForOre(list[j])
        end
        -- let the engine breathe for a frame
        task.wait()
        i = last + 1
    end

    -- After creating all, adjust canvas size later
    task.defer(function()
        task.wait()
        local contentSize = layout.AbsoluteContentSize
        scroll.CanvasSize = UDim2.new(0, 0, 0, contentSize.Y + 8)
    end)
end

-- Efficient add/remove bookkeeping (incremental)
local function updateButtonCount(oreName)
    local entry = partsByName[oreName]
    local count = (entry and entry.count) or 0
    local btnObj = oreButtons[oreName]
    if btnObj and btnObj.Count then
        if btnObj.Count.Text ~= tostring(count) then
            btnObj.Count.Text = tostring(count)
            btnObj.Button.Active = count > 0
            btnObj.Button.BackgroundColor3 = count > 0 and Color3.fromRGB(42,42,48) or Color3.fromRGB(28,28,30)
            btnObj.Button.TextTransparency = count > 0 and 0 or 0.4
        end
    else
        -- create button lazily if a new ore type showed up
        if count > 0 then
            createButtonForOre(oreName)
            updateButtonCount(oreName)
        end
    end
end

local function removePart(part)
    if not part or not part.Name then return end
    local name = part.Name
    local entry = partsByName[name]
    if entry and entry.parts[part] then
        entry.parts[part] = nil
        entry.count = entry.count - 1
        if entry.count <= 0 then
            -- Keep entry to avoid re-creating UI repeatedly; set count=0
            entry.count = 0
        end
        updateButtonCount(name)
    end
    if partConnections[part] then
        partConnections[part]:Disconnect()
        partConnections[part] = nil
    end
end

local function addPart(part)
    if not part or not part:IsA("BasePart") then return end
    local name = part.Name
    if isExcluded(name) then return end
    partsByName[name] = partsByName[name] or { parts = {}, count = 0 }
    if not partsByName[name].parts[part] then
        partsByName[name].parts[part] = true
        partsByName[name].count = partsByName[name].count + 1
    end

    -- connect to AncestryChanged to detect removal
    local conn = part.AncestryChanged:Connect(function(_, parent)
        if not parent then
            removePart(part)
        end
    end)
    partConnections[part] = conn

    updateButtonCount(name)
end

-- Initial population: create all buttons (from master list) in batches (non-blocking)
buildButtonsInBatches(masterOreList, 20)

-- Initial scan of mine folder done in batches to avoid freezing.
task.spawn(function()
    local children = mineFolder:GetChildren()
    local batch = 200 -- number of parts to process per tick; tune to your performance
    local idx = 1
    while idx <= #children do
        local last = math.min(#children, idx + batch - 1)
        for i = idx, last do
            local child = children[i]
            if child and child:IsA("BasePart") and not isExcluded(child.Name) then
                addPart(child)
            end
        end
        idx = last + 1
        task.wait() -- yield for a frame to avoid stall
    end
end)

-- Connect to ChildAdded/Removed to update incrementally
mineFolder.ChildAdded:Connect(function(child)
    -- handle pieces that are added after initial scan
    addPart(child)
end)

mineFolder.ChildRemoved:Connect(function(child)
    removePart(child)
end)

-- Periodic refresh of visible button counts (throttled)
-- Because we update counts incrementally, we only need to refresh occasionally.
local REFRESH_INTERVAL = 1.0 -- once per second; raise if still heavy
local elapsed = 0
RunService.Heartbeat:Connect(function(dt)
    elapsed = elapsed + dt
    if elapsed >= REFRESH_INTERVAL then
        elapsed = 0
        if showCounts then
            for oreName, _ in pairs(oreButtons) do
                updateButtonCount(oreName)
            end
        end
    end
end)

-- Toggle counts button behavior
toggleCountsBtn.MouseButton1Click:Connect(function()
    showCounts = not showCounts
    toggleCountsBtn.Text = showCounts and "Counts: On" or "Counts: Off"
    for _, v in pairs(oreButtons) do
        if v.Count then
            v.Count.Visible = showCounts
        end
    end
end)

-- Dragging logic (unchanged)
local dragging = false
local dragInput, dragStart, startPos
local function updatePosition(input)
    local delta = input.Position - dragStart
    mainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
end

titleBar.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = mainFrame.Position
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

titleBar.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        dragInput = input
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if dragging and input == dragInput then
        updatePosition(input)
    end
end)

-- Minimize toggle
local minimized = false
local originalSize = mainFrame.Size
minimizeBtn.MouseButton1Click:Connect(function()
    minimized = not minimized
    if minimized then
        TweenService:Create(mainFrame, TweenInfo.new(0.18), {Size = UDim2.new(originalSize.X.Scale, originalSize.X.Offset, 0, 34)}):Play()
        contentFrame.Visible = false
    else
        contentFrame.Visible = true
        TweenService:Create(mainFrame, TweenInfo.new(0.18), {Size = originalSize}):Play()
    end
end)

-- Random-teleport hotkey (uses partsByName)
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.Nine then
        local availableTypes = {}
        for oreName, entry in pairs(partsByName) do
            if entry.count and entry.count > 0 then
                table.insert(availableTypes, oreName)
            end
        end
        if #availableTypes > 0 then
            local choice = availableTypes[math.random(1, #availableTypes)]
            teleportToOre(choice)
        end
    end
end)

-- Keep GUI alive on respawn
player.CharacterAdded:Connect(function()
    task.wait(0.2)
    if not gui.Parent then
        gui.Parent = playerGui
    end
end)

-- Cleanup on destroy
script.Destroying:Connect(function()
    clearHighlight()
    for _, conn in pairs(partConnections) do
        if conn and conn.Disconnect then
            conn:Disconnect()
        end
    end
end)
