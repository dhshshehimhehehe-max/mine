-- TeleportOreUI.lua
-- LocalScript â€” previous functionality preserved, with a lightweight search UI added
-- - Adds a search TextBox/button in the title bar so you can quickly find ores.
-- - Search is case-insensitive and filters visible buttons (doesn't recreate UI).
-- - Categories hide automatically when no ores in them match the search.
-- - Lightweight debounce applied so typing doesn't trigger too many updates.

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local task = task
local player = Players.LocalPlayer

if not player then
    player = Players:GetPropertyChangedSignal("LocalPlayer") and Players.LocalPlayer or Players.PlayerAdded:Wait()
end

local playerGui = player:WaitForChild("PlayerGui")
local workspace = game:GetService("Workspace")

-- === Master ore lists per PlaceId ===
local masterOreList = {}
if game.PlaceId == 8549934015 then -- Normal World
    masterOreList = {
        "Magma","Stone","Copper","Basalt","Amber","Diorite","Coal","Crystallized Stone","Nickel","Bedrock","Gold","Granite","Iron",
        "Marble","Etherstone","Prismatistone","Silver","Obsidian","Ice","Voidstone","Ruby","Celestone","Mantle","Goldstone","Barrier",
        "Quartz","Reflectistone","Emerald",
    }
elseif game.PlaceId == 10129505074 then -- Moon World
    masterOreList = {
        "Moon Stone","Tin","Moon Mantle","Jasper","Aluminum","Moon Core","Zinc","Coal","Magma","Copper","Titanium","Legacy Uranium",
        "Lithium","Nickel","Quartz","Gold","Tourmaline","Jade","Silver","Lapis Lazuli","Bismuth","Nebula","Strontium","Scandium",
        "Platinum","Amethyst","Barrier","Garnet","Cobalt","Emerald","Heliodor","Aquamarine","Topaz","Diamond","Beryllium","Morganite",
        "Ruby","Rocc","Moonrock",
    }
else
    masterOreList = {"Stone", "Iron", "Gold", "Diamond"}
end

local excludedOres = {}
if game.PlaceId == 8549934015 then
    excludedOres = {"Magma", "Stone"}
elseif game.PlaceId == 10129505074 then
    excludedOres = {}
end

local function isExcluded(name)
    for _, v in pairs(excludedOres) do
        if v == name then
            return true
        end
    end
    return false
end

local mineFolder = workspace:FindFirstChild("Mine") or workspace:WaitForChild("Mine")

local categoryKeywords = {
    Stone = {"stone", "rock", "bedrock", "mantle", "moon rock", "moonrock"},
    Metal = {"iron", "copper", "gold", "nickel", "tin", "aluminum", "platinum", "titanium", "zinc", "bismuth", "beryllium", "scandium", "strontium", "cobalt"},
    Gem = {"ruby", "emerald", "diamond", "amethyst", "jade", "topaz", "aquamarine", "garnet", "morganite", "tourmalite", "tourmaline", "opal", "heliodor", "lapis"},
}

local function categorizeOre(name)
    local lower = string.lower(name or "")
    for cat, keywords in pairs(categoryKeywords) do
        for _, kw in ipairs(keywords) do
            if string.find(lower, kw, 1, true) then
                return cat
            end
        end
    end
    return "Other"
end

-- === GUI creation (same look) ===
local gui = Instance.new("ScreenGui")
gui.Name = "OreTeleportUI"
gui.ResetOnSpawn = false
gui.Parent = playerGui

local mainFrame = Instance.new("Frame")
mainFrame.Name = "Main"
mainFrame.Size = UDim2.new(0, 360, 0, 420)
mainFrame.Position = UDim2.new(0, 50, 0, 80)
mainFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
mainFrame.BorderSizePixel = 0
mainFrame.Parent = gui
mainFrame.Active = true

local titleBar = Instance.new("Frame")
titleBar.Name = "TitleBar"
titleBar.Size = UDim2.new(1, 0, 0, 34)
titleBar.BackgroundColor3 = Color3.fromRGB(20, 20, 25)
titleBar.BorderSizePixel = 0
titleBar.Parent = mainFrame

local titleLabel = Instance.new("TextLabel")
titleLabel.Name = "Title"
titleLabel.Size = UDim2.new(1, -190, 1, 0) -- reduced width to fit search box & other buttons
titleLabel.Position = UDim2.new(0, 10, 0, 0)
titleLabel.BackgroundTransparency = 1
titleLabel.Text = "Ore Teleport"
titleLabel.TextColor3 = Color3.fromRGB(220,220,220)
titleLabel.TextScaled = true
titleLabel.Font = Enum.Font.GothamBold
titleLabel.TextXAlignment = Enum.TextXAlignment.Left
titleLabel.Parent = titleBar

local minimizeBtn = Instance.new("TextButton")
minimizeBtn.Name = "Minimize"
minimizeBtn.Size = UDim2.new(0, 30, 0, 24)
minimizeBtn.Position = UDim2.new(1, -36, 0, 5)
minimizeBtn.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
minimizeBtn.Text = "-"
minimizeBtn.Font = Enum.Font.GothamBold
minimizeBtn.TextColor3 = Color3.fromRGB(200,200,200)
minimizeBtn.TextScaled = true
minimizeBtn.Parent = titleBar

-- Toggle to enable/disable counts
local showCounts = true
local toggleCountsBtn = Instance.new("TextButton")
toggleCountsBtn.Name = "ToggleCounts"
toggleCountsBtn.Size = UDim2.new(0, 80, 0, 22)
toggleCountsBtn.Position = UDim2.new(1, -130, 0, 6)
toggleCountsBtn.BackgroundColor3 = Color3.fromRGB(50,50,55)
toggleCountsBtn.Text = "Counts: On"
toggleCountsBtn.Font = Enum.Font.Gotham
toggleCountsBtn.TextSize = 14
toggleCountsBtn.TextColor3 = Color3.fromRGB(220,220,220)
toggleCountsBtn.Parent = titleBar

-- Search UI: TextBox + Clear button (placed in title bar)
local searchBox = Instance.new("TextBox")
searchBox.Name = "SearchBox"
searchBox.Size = UDim2.new(0, 140, 0, 22)
searchBox.Position = UDim2.new(1, -250, 0, 6)
searchBox.PlaceholderText = "Search ores..."
searchBox.BackgroundColor3 = Color3.fromRGB(50,50,55)
searchBox.Text = ""
searchBox.Font = Enum.Font.Gotham
searchBox.TextSize = 14
searchBox.TextColor3 = Color3.fromRGB(230,230,230)
searchBox.Parent = titleBar
searchBox.ClearTextOnFocus = false

local clearSearchBtn = Instance.new("TextButton")
clearSearchBtn.Name = "ClearSearch"
clearSearchBtn.Size = UDim2.new(0, 22, 0, 22)
clearSearchBtn.Position = UDim2.new(1, -106, 0, 6)
clearSearchBtn.BackgroundColor3 = Color3.fromRGB(60,60,65)
clearSearchBtn.Text = "X"
clearSearchBtn.Font = Enum.Font.GothamBold
clearSearchBtn.TextSize = 14
clearSearchBtn.TextColor3 = Color3.fromRGB(220,220,220)
clearSearchBtn.Parent = titleBar

local contentFrame = Instance.new("Frame")
contentFrame.Name = "Content"
contentFrame.Size = UDim2.new(1, 0, 1, -34)
contentFrame.Position = UDim2.new(0, 0, 0, 34)
contentFrame.BackgroundTransparency = 1
contentFrame.Parent = mainFrame

local scroll = Instance.new("ScrollingFrame")
scroll.Name = "Scroll"
scroll.Size = UDim2.new(1, -12, 1, -12)
scroll.Position = UDim2.new(0, 6, 0, 6)
scroll.CanvasSize = UDim2.new(0, 0, 0, 0)
scroll.BackgroundTransparency = 1
scroll.ScrollBarThickness = 6
scroll.Active = true
scroll.Selectable = true
scroll.Parent = contentFrame

local layout = Instance.new("UIListLayout")
layout.SortOrder = Enum.SortOrder.LayoutOrder
layout.Padding = UDim.new(0, 6)
layout.Parent = scroll

-- Make the scrolling responsive by updating CanvasSize when content changes
layout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
    scroll.CanvasSize = UDim2.new(0, 0, 0, layout.AbsoluteContentSize.Y + 8)
end)

-- For storing UI objects and bookkeeping
local oreButtons = {} -- oreName -> { Button, CountLabel }
local oreCategory = {} -- oreName -> category
local categoriesCreated = {} -- catName -> true
local partsByName = {} -- oreName -> { parts = { [part] = true }, count = n }
local partConnections = {} -- part -> connection

-- Highlight (unchanged)
local currentHighlight = nil
local function clearHighlight()
    if currentHighlight and currentHighlight.Parent then
        currentHighlight:Destroy()
    end
    currentHighlight = nil
end
local function createHighlight(part)
    clearHighlight()
    if not part or not part:IsA("BasePart") then return end
    local box = Instance.new("BoxHandleAdornment")
    box.Adornee = part
    box.AlwaysOnTop = true
    box.Size = part.Size + Vector3.new(0.08, 0.08, 0.08)
    box.ZIndex = 10
    box.Color = part.Color
    box.Parent = game:GetService("CoreGui")
    currentHighlight = box
end

local function teleportToOre(oreName)
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
        player.CharacterAdded:Wait()
        repeat task.wait() until player.Character:FindFirstChild("HumanoidRootPart")
    end
    local hrp = player.Character.HumanoidRootPart
    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
    if not hrp then return end

    local entry = partsByName[oreName]
    local nearest, nearestDist = nil, math.huge
    if entry then
        for part,_ in pairs(entry.parts) do
            if part and part:IsA("BasePart") then
                local dist = (hrp.Position - part.Position).Magnitude
                if dist < nearestDist then
                    nearest = part
                    nearestDist = dist
                end
            end
        end
    end

    if nearest then
        local targetCFrame = nearest.CFrame + Vector3.new(0, 6.5, 0)
        if humanoid and humanoid.Sit then
            humanoid.Sit = false
        end
        hrp.CFrame = targetCFrame
        createHighlight(nearest)
    else
        clearHighlight()
    end
end

-- Create category frames (if needed) and grid containers
local function ensureCategoryExists(catName)
    if scroll:FindFirstChild("Grid_" .. catName) then return end
    categoriesCreated[catName] = true

    local catFrame = Instance.new("Frame")
    catFrame.Name = "Category_" .. catName
    catFrame.Size = UDim2.new(1, -6, 0, 28)
    catFrame.BackgroundTransparency = 1
    catFrame.Parent = scroll

    local catLabel = Instance.new("TextLabel")
    catLabel.Size = UDim2.new(1, 0, 1, 0)
    catLabel.BackgroundTransparency = 1
    catLabel.Text = catName
    catLabel.TextColor3 = Color3.fromRGB(200,200,200)
    catLabel.Font = Enum.Font.GothamBold
    catLabel.TextScaled = true
    catLabel.Parent = catFrame

    local grid = Instance.new("Frame")
    grid.Name = "Grid_" .. catName
    grid.Size = UDim2.new(1, 0, 0, 0)
    grid.BackgroundTransparency = 1
    grid.Parent = scroll

    local gridLayout = Instance.new("UIGridLayout")
    gridLayout.CellSize = UDim2.new(0, 110, 0, 36)
    gridLayout.CellPadding = UDim2.new(0, 6, 0, 6)
    gridLayout.FillDirection = Enum.FillDirection.Horizontal
    gridLayout.SortOrder = Enum.SortOrder.LayoutOrder
    gridLayout.Parent = grid

    -- Auto-resize the grid height to match its UIGridLayout content so items don't overflow and overlap
    gridLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        grid.Size = UDim2.new(1, 0, 0, gridLayout.AbsoluteContentSize.Y)
    end)
end

-- Create a single button for oreName
local function createButtonForOre(oreName)
    if oreButtons[oreName] then return end
    local cat = categorizeOre(oreName)
    oreCategory[oreName] = cat
    ensureCategoryExists(cat)
    local grid = scroll:FindFirstChild("Grid_" .. cat)
    if not grid then return end

    local btn = Instance.new("TextButton")
    btn.Name = "OreBtn_" .. oreName
    btn.Size = UDim2.new(0, 110, 0, 36)
    btn.BackgroundColor3 = Color3.fromRGB(42, 42, 48)
    btn.BorderSizePixel = 0
    btn.Text = oreName
    btn.Font = Enum.Font.Gotham
    btn.TextSize = 14
    btn.TextColor3 = Color3.fromRGB(230,230,230)
    btn.AutoButtonColor = true
    btn.Parent = grid

    local countLabel = Instance.new("TextLabel")
    countLabel.Name = "Count"
    countLabel.Size = UDim2.new(0, 34, 1, 0)
    countLabel.Position = UDim2.new(1, -36, 0, 0)
    countLabel.BackgroundTransparency = 1
    countLabel.Text = "0"
    countLabel.Font = Enum.Font.Gotham
    countLabel.TextSize = 14
    countLabel.TextColor3 = Color3.fromRGB(170,170,170)
    countLabel.Parent = btn
    countLabel.Visible = showCounts

    btn.MouseButton1Click:Connect(function()
        teleportToOre(oreName)
    end)

    oreButtons[oreName] = {
        Button = btn,
        Count = countLabel,
    }
end

-- Build all buttons from master list in batches to avoid freezing
local function buildButtonsInBatches(list, batchSize)
    batchSize = batchSize or 25
    local i = 1
    while i <= #list do
        local last = math.min(#list, i + batchSize - 1)
        for j = i, last do
            createButtonForOre(list[j])
        end
        task.wait()
        i = last + 1
    end

    task.defer(function()
        task.wait()
        local contentSize = layout.AbsoluteContentSize
        scroll.CanvasSize = UDim2.new(0, 0, 0, contentSize.Y + 8)
    end)
end

local function updateButtonCount(oreName)
    local entry = partsByName[oreName]
    local count = (entry and entry.count) or 0
    local btnObj = oreButtons[oreName]
    if btnObj and btnObj.Count then
        if btnObj.Count.Text ~= tostring(count) then
            btnObj.Count.Text = tostring(count)
            btnObj.Button.Active = count > 0
            btnObj.Button.BackgroundColor3 = count > 0 and Color3.fromRGB(42,42,48) or Color3.fromRGB(28,28,30)
            btnObj.Button.TextTransparency = count > 0 and 0 or 0.4
        end
    else
        if count > 0 then
            createButtonForOre(oreName)
            updateButtonCount(oreName)
        end
    end
end

local function removePart(part)
    if not part or not part.Name then return end
    local name = part.Name
    local entry = partsByName[name]
    if entry and entry.parts[part] then
        entry.parts[part] = nil
        entry.count = entry.count - 1
        if entry.count <= 0 then
            entry.count = 0
        end
        updateButtonCount(name)
    end
    if partConnections[part] then
        partConnections[part]:Disconnect()
        partConnections[part] = nil
    end
end

local function addPart(part)
    if not part or not part:IsA("BasePart") then return end
    local name = part.Name
    if isExcluded(name) then return end
    partsByName[name] = partsByName[name] or { parts = {}, count = 0 }
    if not partsByName[name].parts[part] then
        partsByName[name].parts[part] = true
        partsByName[name].count = partsByName[name].count + 1
    end

    local conn = part.AncestryChanged:Connect(function(_, parent)
        if not parent then
            removePart(part)
        end
    end)
    partConnections[part] = conn

    updateButtonCount(name)
end

-- Initial population: create all buttons (from master list) in batches (non-blocking)
buildButtonsInBatches(masterOreList, 20)

task.spawn(function()
    local children = mineFolder:GetChildren()
    local batch = 200
    local idx = 1
    while idx <= #children do
        local last = math.min(#children, idx + batch - 1)
        for i = idx, last do
            local child = children[i]
            if child and child:IsA("BasePart") and not isExcluded(child.Name) then
                addPart(child)
            end
        end
        idx = last + 1
        task.wait()
    end
end)

mineFolder.ChildAdded:Connect(function(child)
    addPart(child)
end)

mineFolder.ChildRemoved:Connect(function(child)
    removePart(child)
end)

local REFRESH_INTERVAL = 1.0
local elapsed = 0
RunService.Heartbeat:Connect(function(dt)
    elapsed = elapsed + dt
    if elapsed >= REFRESH_INTERVAL then
        elapsed = 0
        if showCounts then
            for oreName, _ in pairs(oreButtons) do
                updateButtonCount(oreName)
            end
        end
    end
end)

toggleCountsBtn.MouseButton1Click:Connect(function()
    showCounts = not showCounts
    toggleCountsBtn.Text = showCounts and "Counts: On" or "Counts: Off"
    for _, v in pairs(oreButtons) do
        if v.Count then
            v.Count.Visible = showCounts
        end
    end
end)

-- Search/filter logic
local function applySearch(query)
    local q = (query or ""):lower()
    -- toggle button visibility based on search
    for oreName, obj in pairs(oreButtons) do
        if obj and obj.Button then
            local visible = (q == "") or (string.find(oreName:lower(), q, 1, true) ~= nil)
            obj.Button.Visible = visible
        end
    end

    -- For each category, hide the category label + grid if no visible buttons inside
    for cat, _ in pairs(categoriesCreated) do
        local grid = scroll:FindFirstChild("Grid_" .. cat)
        local catFrame = scroll:FindFirstChild("Category_" .. cat)
        if grid then
            local anyVisible = false
            for _, child in ipairs(grid:GetChildren()) do
                if child:IsA("TextButton") and child.Visible then
                    anyVisible = true
                    break
                end
            end
            grid.Visible = anyVisible
            if catFrame then
                catFrame.Visible = anyVisible
            end
        end
    end
    -- layout AbsoluteContentSize change handler will update CanvasSize for scrolling
end

-- Debounced search: apply after a short pause in typing
local function scheduleSearch(text)
    local current = text
    task.delay(0.15, function()
        -- only apply if text hasn't changed
        if searchBox.Text == current then
            applySearch(current)
        end
    end)
end

searchBox:GetPropertyChangedSignal("Text"):Connect(function()
    scheduleSearch(searchBox.Text)
end)

searchBox.FocusLost:Connect(function(enterPressed)
    -- immediate apply when focus lost
    applySearch(searchBox.Text)
end)

clearSearchBtn.MouseButton1Click:Connect(function()
    searchBox.Text = ""
    applySearch("")
end)

-- Dragging logic (unchanged)
local dragging = false
local dragInput, dragStart, startPos
local function updatePosition(input)
    local delta = input.Position - dragStart
    mainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
end

titleBar.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = mainFrame.Position
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

titleBar.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        dragInput = input
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if dragging and input == dragInput then
        updatePosition(input)
    end
end)

minimizeBtn.MouseButton1Click:Connect(function()
    local minimized = mainFrame:GetAttribute("minimized")
    if minimized == nil then minimized = false end
    minimized = not minimized
    mainFrame:SetAttribute("minimized", minimized)
    if minimized then
        TweenService:Create(mainFrame, TweenInfo.new(0.18), {Size = UDim2.new(mainFrame.Size.X.Scale, mainFrame.Size.X.Offset, 0, 34)}):Play()
        contentFrame.Visible = false
    else
        contentFrame.Visible = true
        TweenService:Create(mainFrame, TweenInfo.new(0.18), {Size = UDim2.new(mainFrame.Size.X.Scale, mainFrame.Size.X.Offset, 0, 420)}):Play()
    end
end)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.Nine then
        local availableTypes = {}
        for oreName, entry in pairs(partsByName) do
            if entry.count and entry.count > 0 then
                table.insert(availableTypes, oreName)
            end
        end
        if #availableTypes > 0 then
            local choice = availableTypes[math.random(1, #availableTypes)]
            teleportToOre(choice)
        end
    end
end)

player.CharacterAdded:Connect(function()
    task.wait(0.2)
    if not gui.Parent then
        gui.Parent = playerGui
    end
end)

script.Destroying:Connect(function()
    clearHighlight()
    for _, conn in pairs(partConnections) do
        if conn and conn.Disconnect then
            conn:Disconnect()
        end
    end
end)
