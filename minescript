-- TeleportOreUI.lua
-- LocalScript for a draggable, minimizable UI that lists ores in categories and teleports the player to a clicked ore type.
-- Behavior:
--  - Detects which world (PlaceId) you're in and applies the appropriate excluded-ore blacklist.
--  - Scans workspace.Mine for ore parts and groups available ore types into categories (Stone, Metal, Gem, Other).
--  - Builds a UI in PlayerGui that's draggable and minimizable. Each ore type is a button that shows current available count.
--  - Clicking an ore button teleports your character to the nearest ore of that type. If that ore is mined, clicking again will try to teleport to another available ore of the same type.
--  - The UI automatically refreshes when ores are added/removed in workspace.Mine.
-- Note: This script is written as a LocalScript and should run in a LocalPlayer context.

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local player = Players.LocalPlayer

if not player then
    -- If running too early, wait for player
    player = Players:GetPropertyChangedSignal("LocalPlayer") and Players.LocalPlayer or Players.PlayerAdded:Wait()
end

local playerGui = player:WaitForChild("PlayerGui")
local workspace = game:GetService("Workspace")

-- Determine excluded ores per PlaceId (the lists you provided are used as blacklist)
local excludedOres = {}
if game.PlaceId == 8549934015 then -- Normal World
    excludedOres = {"Magma", "Stone", "Copper", "Basalt", "Amber", "Diorite", "Coal", "Crystallized Stone", "Nickel", "Bedrock", "Gold", "Granite", "Iron", "Marble", "Etherstone", "Prismatistone","Silver","Obsidian","Ice","Voidstone","Ruby","Celestone","Mantle","Goldstone","Barrier","Quartz","Reflectistone","Emerald"}
elseif game.PlaceId == 10129505074 then -- Moon World
    excludedOres = {"Moon Stone", "Tin", "Moon Mantle", "Jasper", "Aluminum", "Moon Core", "Zinc", "Coal", "Magma", "Copper", "Titanium", "Legacy Uranium", "Lithium", "Nickel", "Quartz", "Gold", "Tourmaline","Jade","Silver","Lapis Lazuli","Bismuth","Nebula","Strontium","Scandium","Platinum","Amethyst","Barrier","Garnet","Cobalt","Emerald","Heliodor","Aquamarine","Topaz","Diamond","Beryllium","Morganite","Ruby","Rocc","Moonrock","nil"}
else
    -- Default: empty blacklist
    excludedOres = {}
end

local function isExcluded(name)
    for _, v in pairs(excludedOres) do
        if v == name then
            return true
        end
    end
    return false
end

-- Folder with ore parts
local mineFolder = workspace:FindFirstChild("Mine") or workspace:WaitForChild("Mine")

-- Utility: categorize ore by name using simple keyword heuristics
local categoryKeywords = {
    Stone = {"stone", "rock", "bedrock", "mantle", "moon rock", "moonrock"},
    Metal = {"iron", "copper", "gold", "nickel", "tin", "aluminum", "platinum", "titanium", "zinc", "bismuth", "beryllium", "scandium", "strontium", "cobalt"},
    Gem = {"ruby", "emerald", "diamond", "amethyst", "jade", "topaz", "aquamarine", "garnet", "morganite", "tourmaline", "opal", "heliodor", "lapis", "opal"},
}

local function categorizeOre(name)
    local lower = string.lower(name or "")
    for cat, keywords in pairs(categoryKeywords) do
        for _, kw in ipairs(keywords) do
            if string.find(lower, kw, 1, true) then
                return cat
            end
        end
    end
    return "Other"
end

-- GUI creation
local gui = Instance.new("ScreenGui")
gui.Name = "OreTeleportUI"
gui.ResetOnSpawn = false
gui.Parent = playerGui

-- Main frame / title bar
local mainFrame = Instance.new("Frame")
mainFrame.Name = "Main"
mainFrame.Size = UDim2.new(0, 360, 0, 420)
mainFrame.Position = UDim2.new(0, 50, 0, 80)
mainFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
mainFrame.BorderSizePixel = 0
mainFrame.Parent = gui
mainFrame.Active = true

local titleBar = Instance.new("Frame")
titleBar.Name = "TitleBar"
titleBar.Size = UDim2.new(1, 0, 0, 34)
titleBar.BackgroundColor3 = Color3.fromRGB(20, 20, 25)
titleBar.BorderSizePixel = 0
titleBar.Parent = mainFrame

local titleLabel = Instance.new("TextLabel")
titleLabel.Name = "Title"
titleLabel.Size = UDim2.new(1, -70, 1, 0)
titleLabel.Position = UDim2.new(0, 10, 0, 0)
titleLabel.BackgroundTransparency = 1
titleLabel.Text = "Ore Teleport"
titleLabel.TextColor3 = Color3.fromRGB(220,220,220)
titleLabel.TextScaled = true
titleLabel.Font = Enum.Font.GothamBold
titleLabel.TextXAlignment = Enum.TextXAlignment.Left
titleLabel.Parent = titleBar

local minimizeBtn = Instance.new("TextButton")
minimizeBtn.Name = "Minimize"
minimizeBtn.Size = UDim2.new(0, 30, 0, 24)
minimizeBtn.Position = UDim2.new(1, -36, 0, 5)
minimizeBtn.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
minimizeBtn.Text = "-"
minimizeBtn.Font = Enum.Font.GothamBold
minimizeBtn.TextColor3 = Color3.fromRGB(200,200,200)
minimizeBtn.TextScaled = true
minimizeBtn.Parent = titleBar

local contentFrame = Instance.new("Frame")
contentFrame.Name = "Content"
contentFrame.Size = UDim2.new(1, 0, 1, -34)
contentFrame.Position = UDim2.new(0, 0, 0, 34)
contentFrame.BackgroundTransparency = 1
contentFrame.Parent = mainFrame

local scroll = Instance.new("ScrollingFrame")
scroll.Name = "Scroll"
scroll.Size = UDim2.new(1, -12, 1, -12)
scroll.Position = UDim2.new(0, 6, 0, 6)
scroll.CanvasSize = UDim2.new(0, 0, 0, 0)
scroll.BackgroundTransparency = 1
scroll.ScrollBarThickness = 6
scroll.Parent = contentFrame

local layout = Instance.new("UIListLayout")
layout.SortOrder = Enum.SortOrder.LayoutOrder
layout.Padding = UDim.new(0, 6)
layout.Parent = scroll

-- For storing buttons by ore name
local oreButtons = {}

-- Highlight / optional box adornment on target ore
local currentHighlight = nil
local function clearHighlight()
    if currentHighlight and currentHighlight.Parent then
        currentHighlight:Destroy()
    end
    currentHighlight = nil
end

local function createHighlight(part)
    clearHighlight()
    if not part or not part:IsA("BasePart") then return end
    local box = Instance.new("BoxHandleAdornment")
    box.Adornee = part
    box.AlwaysOnTop = true
    box.Size = part.Size + Vector3.new(0.08, 0.08, 0.08)
    box.ZIndex = 10
    box.Color = part.Color
    box.Parent = game:GetService("CoreGui") -- Adornments often live in CoreGui
    currentHighlight = box
end

-- Teleport function: teleport local player to nearest ore of a given name
local function teleportToOre(oreName)
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
        player.CharacterAdded:Wait()
        repeat wait() until player.Character:FindFirstChild("HumanoidRootPart")
    end
    local hrp = player.Character.HumanoidRootPart
    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
    if not hrp then return end

    local nearest = nil
    local nearestDist = math.huge
    for _, part in ipairs(mineFolder:GetChildren()) do
        if part:IsA("BasePart") and part.Name == oreName and not isExcluded(part.Name) then
            local dist = (hrp.Position - part.Position).Magnitude
            if dist < nearestDist then
                nearest = part
                nearestDist = dist
            end
        end
    end

    if nearest then
        -- Teleport slightly above the ore
        local targetCFrame = nearest.CFrame + Vector3.new(0, 6.5, 0)
        -- Try to set CFrame safely
        if humanoid and humanoid.Sit then
            humanoid.Sit = false
        end
        hrp.CFrame = targetCFrame
        createHighlight(nearest)
    else
        -- No ore found: clear highlight and optionally flash button
        clearHighlight()
        -- simple feedback: print (you can replace with GUI feedback)
        -- print("No more ores of type:", oreName)
    end
end

-- Build the UI categories and buttons based on current ores
local function rebuildUI()
    -- Clear previous category frames
    for _, child in ipairs(scroll:GetChildren()) do
        if child:IsA("Frame") and child.Name ~= "Template" then
            child:Destroy()
        end
    end
    oreButtons = {}

    -- Gather ore types available (excluding blacklisted)
    local oreTypes = {}
    for _, part in ipairs(mineFolder:GetChildren()) do
        if part:IsA("BasePart") then
            local name = part.Name
            if name and not isExcluded(name) then
                oreTypes[name] = true
            end
        end
    end

    -- Group ore types into categories
    local categories = {}
    for oreName, _ in pairs(oreTypes) do
        local cat = categorizeOre(oreName)
        categories[cat] = categories[cat] or {}
        table.insert(categories[cat], oreName)
    end

    -- Sort category names for stable UI order
    local catNames = {}
    for k in pairs(categories) do table.insert(catNames, k) end
    table.sort(catNames)

    local yOffset = 0
    for _, catName in ipairs(catNames) do
        local catFrame = Instance.new("Frame")
        catFrame.Name = "Category_" .. catName
        catFrame.Size = UDim2.new(1, -6, 0, 28)
        catFrame.LayoutOrder = yOffset
        catFrame.BackgroundTransparency = 1
        catFrame.Parent = scroll

        local catLabel = Instance.new("TextLabel")
        catLabel.Size = UDim2.new(1, 0, 1, 0)
        catLabel.BackgroundTransparency = 1
        catLabel.Text = catName
        catLabel.TextColor3 = Color3.fromRGB(200,200,200)
        catLabel.Font = Enum.Font.GothamBold
        catLabel.TextScaled = true
        catLabel.Parent = catFrame

        local grid = Instance.new("Frame")
        grid.Name = "Grid_" .. catName
        grid.Size = UDim2.new(1, 0, 0, 0) -- will grow
        grid.BackgroundTransparency = 1
        grid.Parent = scroll

        local gridLayout = Instance.new("UIGridLayout")
        gridLayout.CellSize = UDim2.new(0, 110, 0, 36)
        gridLayout.CellPadding = UDim2.new(0, 6, 0, 6)
        gridLayout.FillDirection = Enum.FillDirection.Horizontal
        gridLayout.SortOrder = Enum.SortOrder.LayoutOrder
        gridLayout.Parent = grid

        -- Create buttons for each ore in this category
        table.sort(categories[catName])
        for _, oreName in ipairs(categories[catName]) do
            local btn = Instance.new("TextButton")
            btn.Name = "OreBtn_" .. oreName
            btn.Size = UDim2.new(0, 110, 0, 36)
            btn.BackgroundColor3 = Color3.fromRGB(42, 42, 48)
            btn.BorderSizePixel = 0
            btn.Text = oreName
            btn.Font = Enum.Font.Gotham
            btn.TextSize = 14
            btn.TextColor3 = Color3.fromRGB(230,230,230)
            btn.AutoButtonColor = true
            btn.LayoutOrder = 1
            btn.Parent = grid

            local countLabel = Instance.new("TextLabel")
            countLabel.Name = "Count"
            countLabel.Size = UDim2.new(0, 34, 1, 0)
            countLabel.Position = UDim2.new(1, -36, 0, 0)
            countLabel.BackgroundTransparency = 1
            countLabel.Text = "0"
            countLabel.Font = Enum.Font.Gotham
            countLabel.TextSize = 14
            countLabel.TextColor3 = Color3.fromRGB(170,170,170)
            countLabel.Parent = btn

            -- Click behavior: teleport to nearest ore of this type
            btn.MouseButton1Click:Connect(function()
                teleportToOre(oreName)
            end)

            oreButtons[oreName] = {
                Button = btn,
                Count = countLabel,
            }
        end

        yOffset = yOffset + 1
    end

    -- Adjust canvas size
    RunService.Heartbeat:Once(function()
        -- Slight delay to let layouts compute
        local contentSize = layout.AbsoluteContentSize
        scroll.CanvasSize = UDim2.new(0, 0, 0, contentSize.Y + 8)
    end)
end

-- Update counts for each ore button (call frequently or when children change)
local function refreshCounts()
    local counts = {}
    for _, part in ipairs(mineFolder:GetChildren()) do
        if part:IsA("BasePart") and not isExcluded(part.Name) then
            counts[part.Name] = (counts[part.Name] or 0) + 1
        end
    end
    for oreName, btnObj in pairs(oreButtons) do
        local n = counts[oreName] or 0
        if btnObj.Count then
            btnObj.Count.Text = tostring(n)
        end
        -- Optionally disable button if no ores
        btnObj.Button.Active = n > 0
        btnObj.Button.BackgroundColor3 = n > 0 and Color3.fromRGB(42,42,48) or Color3.fromRGB(28,28,30)
        btnObj.Button.TextTransparency = n > 0 and 0 or 0.4
    end
end

-- Watch for mine folder changes to rebuild UI if needed
mineFolder.ChildAdded:Connect(function(child)
    -- Small debounce to avoid rebuild thrash
    rebuildUI()
    refreshCounts()
end)
mineFolder.ChildRemoved:Connect(function(child)
    rebuildUI()
    refreshCounts()
end)

-- Also periodically refresh counts in case ores are mined/respawned without ChildAdded/Removed triggers
local heartbeatConn
heartbeatConn = RunService.Heartbeat:Connect(function(dt)
    refreshCounts()
end)

-- Dragging logic for titleBar
local dragging = false
local dragInput, dragStart, startPos

local function updatePosition(input)
    local delta = input.Position - dragStart
    mainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
end

titleBar.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = mainFrame.Position
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

titleBar.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        dragInput = input
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if dragging and input == dragInput then
        updatePosition(input)
    end
end)

-- Minimize toggle
local minimized = false
local originalSize = mainFrame.Size
minimizeBtn.MouseButton1Click:Connect(function()
    minimized = not minimized
    if minimized then
        -- Shrink content
        local goal = {Size = UDim2.new(originalSize.X.Scale, originalSize.X.Offset, 0, 34)}
        TweenService:Create(mainFrame, TweenInfo.new(0.18), goal):Play()
        contentFrame.Visible = false
    else
        contentFrame.Visible = true
        local goal = {Size = originalSize}
        TweenService:Create(mainFrame, TweenInfo.new(0.18), {Size = originalSize}):Play()
    end
end)

-- Initial build
rebuildUI()
refreshCounts()

-- Keep UI alive on respawn: re-parent if PlayerGui resets
player.CharacterAdded:Connect(function()
    wait(0.2)
    -- ensure gui present after respawn
    if not gui.Parent then
        gui.Parent = playerGui
    end
end)

-- Optional: keybind to teleport to random available ore (kept from your original script)
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.Nine then
        -- Teleport to a random available ore type
        local availableTypes = {}
        for oreName, data in pairs(oreButtons) do
            if tonumber(data.Count.Text) and tonumber(data.Count.Text) > 0 then
                table.insert(availableTypes, oreName)
            end
        end
        if #availableTypes > 0 then
            local choice = availableTypes[math.random(1, #availableTypes)]
            teleportToOre(choice)
        end
    end
end)

-- Clean up on script destroy
script.Destroying:Connect(function()
    clearHighlight()
    if heartbeatConn then heartbeatConn:Disconnect() end
end)
